;; This project has 2 parts - data munging the source files and trying all permutations.
;; Let's munge that data!

;; First part is of the format "NAME: some text"
;; Then the line "NODE_COORD_SECTION"
;; then enumerated line by line like this: "1 87.951292 2.658162"

(ql:quickload "cl-ppcre")
(ql:quickload :iterate)
(defpackage brute-force
  (:use :common-lisp :iterate))

(in-package :brute-force)


(defmacro for-in-file-lines ((var-name file-name) &body body)
  (let ((in (gensym)))
    `(let ((,in (open ,file-name :if-does-not-exist nil)))
       (when ,in
	 (loop for ,var-name = (read-line ,in nil)
	    while ,var-name do (progn ,@body)))
	 (close ,in))))

(defun get-points (filename)
  (let ((is-header t)
	(header nil)
	(points nil))
    (for-in-file-lines
	(line filename)
      (cond ((ppcre:scan "NODE_COORD_SECTION" line)
	     (setq is-header nil))
	    (is-header
	     (ppcre:register-groups-bind (key value)
		 ("(\\w+): (\\w+)" line)
	       (push (list key value) header)))
	    (t
	     (ppcre:register-groups-bind (num x y)
		 ("(\\d+) ([,.\\d]+) ([,.\\d]+)" line)
	       (push (mapcar #'read-from-string (list num x y)) points)))))
    (list header points)))

;; get into the REAL programming
(defun seq-permutations (seq &optional (n 0))
  " create all permutations of a seq, return list of sequences"
  (let ((len (length seq)))
    (cond ((= n (1- len))
	   (list (copy-seq seq)))
	  (t
	   (loop for i from n below len
	      append (progn
			(rotatef (aref seq i) (aref seq n))
			(let ((result 
			       (seq-permutations seq (1+ n))))
			  (rotatef (aref seq i) (aref seq n))
			  result)))))))

(defun distance (point-1 point-2)
  " euclidean distance, based on (id x y) format of points"
  (destructuring-bind ((n1 x1 y1) (n2 x2 y2)) (list point-1 point-2)
    (declare (ignore n1 n2))
    (sqrt (+ (expt (- x1 x2) 2) (expt (- y1 y2) 2)))))


(defun evaluate (seq-of-points)
  " gives distance of some traversal"
  (iter (for point-2 in-vector seq-of-points)
	   (for point-1 previous point-2)
	   (if-first-time (next-iteration))
	   (sum (distance point-1 point-2))))
;;(evaluate #((1 1.2 1.3) (2 0.1 0.2) (2 0.9 0.2)))

(defun vector-to-list (vec)
  (iter (for x in-vector vec)
	(collect x)))

(defun find-best-path (filename)
  "big ol' finder function"
  (let* ((header-points (get-points filename))
	 (header (car header-points))
	 (points (cadr header))
	 (permutations (seq-permutations (apply #'vector points))))
    (print header)
    (iter (for list-of-points in permutations)
	  (for cost = (evaluate list-of-points))
	  (finding (list cost (vector-to-list list-of-points)) minimizing cost))))
	

(print (find-best-path "Random9.tsp"))
(print (find-best-path "Random8.tsp"))
(print (find-best-path "Random7.tsp"))
(print (find-best-path "Random6.tsp"))
(print (find-best-path "Random5.tsp"))
(print (find-best-path "Random4.tsp"))
(print (find-best-path "Random10.tsp"))
(print (find-best-path "Random11.tsp"))
(print (find-best-path "Random12.tsp"))

